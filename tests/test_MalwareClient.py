# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import os
import types
import unittest
from freezegun import freeze_time
import mandiant_threatintel
import vcr

mock_vcr = vcr.VCR(
    cassette_library_dir="fixtures/MalwareClient",
    decode_compressed_response=True,
    path_transformer=vcr.VCR.ensure_suffix(".yaml"),
)


class Test_Malware_APIResponse(unittest.TestCase):

  def setUp(self) -> None:
    self.mock_base_client: mandiant_threatintel.ThreatIntelClient = (
        unittest.mock.create_autospec(mandiant_threatintel.ThreatIntelClient)
    )

    self.mock_malware_client: mandiant_threatintel.MalwareClient = (
        unittest.mock.create_autospec(mandiant_threatintel.MalwareClient)
    )

  def test_init_malware_from_json(self):
    mock_response = {
        "actors": [],
        "audience": [
            {"name": "intel_fusion", "license": "INTEL_RBI_FUS"},
            {"name": "intel_oper", "license": "INTEL_RBI_OPS"},
            {"name": "tlp_marking", "license": "amber"},
        ],
        "description": "DESCRIPTION",
        "detections": [],
        "id": "malware--FAKE-UUID",
        "industries": [],
        "inherently_malicious": 1,
        "last_activity_time": "2022-10-20T02:12:11.000Z",
        "last_updated": "2022-10-20T02:12:11.000Z",
        "malware": [],
        "name": "MALWARE_NAME",
        "operating_systems": ["Windows"],
        "type": "malware",
        "yara": [],
        "is_publishable": True,
        "intel_free": False,
        "counts": {
            "reports": 0,
            "capabilities": 9,
            "malware": 0,
            "actors": 0,
            "detections": 0,
            "cve": 0,
            "aliases": 0,
            "industries": 0,
            "attack_patterns": 14,
        },
        "aliases": [],
        "capabilities": [
            {
                "name": "CAPABILITY_NAME",
                "description": "CAPABILITY_DESCRIPTION",
            },
        ],
        "cve": [],
        "roles": ["FAKE_ROLE"],
    }
    malware = mandiant_threatintel.Malware.from_json_response(
        response=mock_response, client=self.mock_base_client
    )

    self.assertIsInstance(malware, mandiant_threatintel.Malware)
    self.assertEqual(malware.name, "MALWARE_NAME")

  def test_init_malware_from_bad_json(self):
    mock_response = {}
    self.assertRaises(
        ValueError,
        mandiant_threatintel.Malware.from_json_response,
        response=mock_response,
        client=self.mock_base_client,
    )

  def test_init_malware_from_identifier(self):
    malware = mandiant_threatintel.Malware.from_identifier(
        "MALWARE_ID", self.mock_base_client
    )

    self.assertIsInstance(malware, mandiant_threatintel.Malware)
    self.assertEqual(malware.id, "MALWARE_ID")


class Test_MalwareClient(unittest.TestCase):

  def setUp(self) -> None:
    self.API_KEY = os.environ.get("API_KEY")
    self.SECRET_KEY = os.environ.get("SECRET_KEY")

    if not self.API_KEY or not self.SECRET_KEY:
      self.TOKEN = "FAKE_TOKEN"
      self.base_client = mandiant_threatintel.ThreatIntelClient(
          bearer_token=self.TOKEN
      )
    else:
      self.base_client = mandiant_threatintel.ThreatIntelClient(
          api_key=self.API_KEY, secret_key=self.SECRET_KEY
      )

    self.malware_client = self.base_client.Malware

  @mock_vcr.use_cassette
  def test_get_malware_by_name(self):
    malware = self.malware_client.get("SMOKELOADER")
    self.assertIsInstance(malware, mandiant_threatintel.Malware)

    self.assertIsNotNone(malware.name)
    self.assertEqual(
        malware.id, "malware--bc1aac4f-7b86-537d-8e37-840218794b8e"
    )

  @mock_vcr.use_cassette
  def test_get_malware_by_id(self):
    malware = self.malware_client.get(
        "malware--bc1aac4f-7b86-537d-8e37-840218794b8e"
    )
    self.assertIsInstance(malware, mandiant_threatintel.Malware)

    self.assertIsNotNone(malware.id)
    self.assertEqual(malware.name, "SMOKELOADER")

  @mock_vcr.use_cassette
  def test_get_all_attributes(self):
    malware = self.malware_client.get(
        "malware--bc1aac4f-7b86-537d-8e37-840218794b8e"
    )

    attributes_list = [
        attr
        for attr in dir(malware)
        if attr[0:1] != "_" and attr[0:4] != "from"
    ]
    for attr in attributes_list:
      attr_value = malware.__getattr__(attr)
      if isinstance(attr_value, types.GeneratorType):
        attr_value = [v for v in attr_value]

      print(f"{attr}: {attr_value}")

  @mock_vcr.use_cassette
  def test_get_list_multiple_pages(self):
    malware_list = [m for m in self.malware_client.get_list(page_size=1)]

    self.assertEqual(len(malware_list), 2)

  @mock_vcr.use_cassette
  def test_get_list_single_page(self):
    malware_list = [m for m in self.malware_client.get_list(page_size=50)]

    self.assertEqual(len(malware_list), 1)


if __name__ == "__main__":
  unittest.main()
